* 상태 = state 관리 :
- useState()
- component 상에 변화 및 업데이트가 필요한 요소가 존재 => 관리
- 하나의 컴포넌트 안에 관리해야할 상태가 많아지면 어떤 문제?
- 컴포넌트 state 업데이트가되면, 리렌더링
- 리엑트를 사용하는 이유?
> 컴포넌트 & 가상돔 => CSR => SSR UI 화면 출력 매우 빠르고 효율적이다

* 상태관리의 효율성!!!
=> useReducer 리액트 훅

*useState() : 컴포넌트 바깥에서 실행해본 적 없음
=> 1번만 실행되고 => 무한 반복
=> setCount함수 컴포넌트 바깥으로 나가게 되면 컴포넌트가 리랜더링 되는 순간 count값을 최초의 초기값으로 reset


* 최적화
- 작업중인 모든 컴포넌트와 함수를 다 최적화 => 불가/쓸데없는 짓
(* 반드시 꼭 필요하다고 생각하는 요소 최적화!!)
- 최적화는 반드시 컴포넌트의 작업이 어느정도 완료가 되는 시점에서만 해야함
(기능구현 > 최적화)
- 최적화는 정답이 없음

React.js 최적화 3가지 방법
1) 리액트 훅 : useMemo
- 메모이제이션
*메모이제이션을 하고자 하는 함수를 콜백함수로 사용, 두번째 매게 변수로 의존성 배열

- 불필요한 함수 재호출 방지를 하고자 할 떄

2) React.memo(리렌더링을 방지하고자하는 컴포넌트)
- 불필요한 컴포넌트 리렌더링을 방지하고자 할 떄

* 컴포넌트가 랜더링 3대 포인트
- state 상태 값이 변화
- props 값 변화
- 부모컴포넌트 렌더링 => 자식 렌더링
함수 => 객체기반 자료

3) useCallback() 리액트 훅
useCallback(콜백함수, 의존성배열)
useEffect(콜백함수, 의존성배열)

* 데이터 효율성

props Drilling 문제

context : 책 => 목차 => 맥락

context를 활용한 API => 

데이터를 공급한는 root 컴포넌트에서는 
React.createContext() 활용해서 객체 컴포넌트를 생성
생성된 객체 컴포넌트에서 .Provider라는 속성을 사용해야지만 데이터를 공급할 수 있는 환경설정 가능!!

이때 root 컴포넌트에서 공급 받은 데이터 중 자식 및 손자 컴포넌트에 전달하고자 하는 데이터는 value라는 key를 활용해서 정의하면됨

이제. 데이터를 공급받아야하는 컴포넌트에서 준비
react 라이브러리에서 useContext훅을 찾아와서 해당 훅 함수의 반환값을 특정 변수에 할당
(*이때, 해당 훅 함수의 매게변수는 부모요소에서 정의했던 context API 컴포넌트로 적용)

리팩토링
=> JS함수기능 => 요소